import numpy as np
import os, sys
import pickle
import readfof
import torch

from kymatio.torch import HarmonicScattering3D
from kymatio.scattering3d.backend.torch_backend \
    import TorchBackend3D

import MAS_library as MASL


#=== DICTIONARIES =====================================================================
order_folders = {
    'fiducial'  : 0,
    'h_m'       : 1,
    'h_p'       : 2,
    'Mnu_p'     : 3,
    'Mnu_pp'    : 4,
    'Mnu_ppp'   : 5,
    'ns_m'      : 6,
    'ns_p'      : 7,
    'Ob2_m'     : 8,
    'Ob2_p'     : 9,
    'Om_m'      : 10,
    'Om_p'      : 11,
    's8_m'      : 12,
    's8_p'      : 13,
    'w_m'       : 14,
    'w_p'       : 15,
    'zeldovich' : 16
}

cosmological_pars = {
    'Om'  : 0,
    'Ob'  : 1,
    'h'   : 2,
    'ns'  : 3,
    's8'  : 4,
    'w'   : 5,
    'Mnu' : 6
}

order_dimension = {
    'Om'  : 0,
    'Ob'  : 1,
    'Ob2' : 1,
    'h'   : 2,
    'ns'  : 3,
    's8'  : 4,
    'w'   : 5,
    'Mnu' : 6
}

boolean = {
    'True' : 1,
    'TRUE' : 1,
    'true' : 1,
    'False' : 0,
    'FALSE' : 0,
    'false' : 0
 }

COSMOPAR = {
#                   | Om   | Ob   |   h   |  n_s  | s_8 | Mnu | w |

    'fiducial' :    [0.3175, 0.049, 0.6711, 0.9624, 0.834, 0, -1],
    'zeldovich':    [0.3175, 0.049, 0.6711, 0.9624, 0.834, 0, -1],
    
    'Mnu_p' :       [0.3175, 0.049, 0.6711, 0.9624, 0.834, 0.1, -1],
    'Mnu_pp' :      [0.3175, 0.049, 0.6711, 0.9624, 0.834, 0.2, -1],
    'Mnu_ppp' :     [0.3175, 0.049, 0.6711, 0.9624, 0.834, 0.4, -1],
    
    'h_m' :         [0.3175, 0.049, 0.6511, 0.9624, 0.834, 0, -1],
    'h_p' :         [0.3175, 0.049, 0.6911, 0.9624, 0.834, 0, -1],
    
    'ns_m' :        [0.3175, 0.049, 0.6711, 0.9424, 0.834, 0, -1],
    'ns_p' :        [0.3175, 0.049, 0.6711, 0.9824, 0.834, 0, -1],
    
    'Ob_m' :        [0.3175, 0.048, 0.6711, 0.9624, 0.834, 0, -1],
    'Ob_p' :        [0.3175, 0.050, 0.6711, 0.9624, 0.834, 0, -1],
    'Ob2_m' :       [0.3175, 0.047, 0.6711, 0.9624, 0.834, 0, -1],
    'Ob2_p' :       [0.3175, 0.051, 0.6711, 0.9624, 0.834, 0, -1],
    
    'Om_m' :        [0.3075, 0.049, 0.6711, 0.9624, 0.834, 0, -1],
    'Om_p' :        [0.3275, 0.049, 0.6711, 0.9624, 0.834, 0, -1],
    
    's8_m' :        [0.3175, 0.049, 0.6711, 0.9624, 0.819, 0, -1],
    's8_p' :        [0.3175, 0.049, 0.6711, 0.9624, 0.849, 0, -1],
    
    'w_m' :         [0.3175, 0.049, 0.6711, 0.9624, 0.834, 0, -0.95],
    'w_p' :         [0.3175, 0.049, 0.6711, 0.9624, 0.834, 0, -1.05]
}
"""
Dictionary to assegnate to a cosmology its parameters
Ordered pairing cosmologies and the first one in with _m, the second one _p
"""

VarCosmoPar = {
    'd_h'  : 0.02,
    'd_ns' : 0.02,
    'd_Ob' : 0.001,
    'd_Ob2': 0.002,
    'd_Om' : 0.01,
    'd_s8' : 0.015,
    'd_w'  : -0.05
}
"""Values of deviations from fiducial cosmological parameters.
"""

fiducial_vals = {
    'Ob'  : 0.3175,
    'Ob2' : 0.3175,
    'Om'  : 0.049,
    'h'   : 0.6711,
    'n_s' : 0.9624,
    'ns'  : 0.9624,
    's_8' : 0.834,
    's8'  : 0.834,
    'Mnu' : 0,
    'w'   : -1
}
"""Values of fiducial cosmological parameters.
"""


#=== PARSERS =======================================================================

def info_name(name):
    """Obtain realization information from .wst file
    Returns:
    - cells per side of density grid
    - cells per side of wst grid
    - number of realizations
    """
    info = name.split('_')[-3:]
    info[2] = info[2].replace(".wst", "")
    N_hgrid = info[0]
    N_WSTgrid = info[1]
    n_realiz = info[2].replace(".wst", "")
    return [int(N_hgrid), int(N_WSTgrid), int(n_realiz)]

def cosmo_parser(name):
    """Obtain name cosmology from .wst file"""
    info = name.split('_')
    if info[0] == "fiducial":
        return info[0]
    elif info[0] == "zeldovich":
        return info[0]
    else:
        return info[0] + "_" + info[1]

#=== EVALUAERS =======================================================================

def HaloWST_one_f_MASL(filename, HarmonicScattering3D, snapnum=2, N_hgrid=256, hlength=1000, N_WSTgrid=256, j=4, l=4):
    """Funcion that evaluates Scattering Transform coefficients of first and second order,
    using a halo database from Quijote simulations.
    NB: this function uses `MAS_library.MA()` to generate density matrix, not `myCIC`.

    Arguments:
    - `filename`: name of the file conaining WST coefficients of first and second order
    - `snapdir` : the tree to the directory containing the datas, STOP before '/groups_';
    - `snapnum` : indicates the choosen redshift (def: 2)
    - `N_hgrid` : number of cells to divide the halos catalogue (def: 256)
    - `hlength` : dimension of the cubic simulation (def: 1000 Mpc/h)
    - `N_WSTgrid` : number of cells to divide the density field, generated by myCIC,
      to calculate WST coefficients (def: 256)
    - `j` : coefficient for scattering transform evaluation (def: 4)
    - `l` : coefficient for scattering transform evaluation (def: 4)
    - `i` : oprional, svariable for print execution time, takes value from iterable object of for loop

    Returns:
    - prints fist and second order scattering coefficients into a single files as 1D array.
    """

    # gc.collect()

    S = HarmonicScattering3D(J=j, L=l, shape=(N_WSTgrid, N_WSTgrid, N_WSTgrid), sigma_0=0.8, integral_powers=[0.8])

    datas = readfof.FoF_catalog(snapdir, snapnum, read_IDs=False)
    pos_h = datas.GroupPos/1e3                     # positions in Mpc/h
    mass = datas.GroupMass * 1e10                  # masses in M_sun/h
    dens = np.zeros((N_hgrid,N_hgrid,N_hgrid), dtype=np.float32)
    MASL.MA(pos_h.astype(np.float32), dens, hlength, 'CIC', W = mass.astype(np.float32))
    dens /= np.mean(dens, dtype=np.float64)
    dens -= 1.0  
    Sx = S.scattering(torch.from_numpy(dens))

    with open('/home/riccardo/WST-files/'+filename, 'ab') as file:
        pickle.dump(torch.flatten(Sx, start_dim=0).cpu().detach().numpy(), file)

def CALCULUS(N_hgrid = 256, N_WSTgrid = 256, n_realiz = -1, Ff = 'fiducial'):
    """Evaluates WST coefficients and print them in one/two files (this is an option) for given folders
    using `HaloWST_one_f_MASL`
    """
    
    # define desired redshift
    snapnum = 2
    # z_dict = {4:0.0, 3:0.5, 2:1.0, 1:2.0, 0:3.0}
    # redshift = z_dict[snapnum]

    # define root path where to find hale catalogues
    
    # root = '/media/fuffolo97/HDD1/UNI/Tesi/Halos/FoF/'
    # root = '/media/fuffolo97/HDD1/UNI/Tesi/Halos/'
    root = '/workplace/riccardo/Halos/'

    # choose cosmologies 
    folder = Ff

    # loop over cosmologies, calculate and create file WST coeff
    if n_realiz < 0:
        in_realizations = os.listdir(root+folder)
        num = len(in_realizations)
    else:
        num = n_realiz
        print(root+folder)
        in_realizations = os.listdir(root+folder)[0:num]
        pass

    filename = '_coefficients_'+str(N_hgrid)+"_"+str(N_WSTgrid)+"_"+str(num)+'.wst'

    # delete existing file, want a new one (not extending it)
    if os.path.exists('/home/riccardo/WST-files/'+folder+filename):
        os.remove('/home/riccardo/WST-files/'+folder+filename)
    
    for i in in_realizations:
        snapdir = root + folder + '/' + i
        HaloWST_one_f_MASL(folder+filename, snapdir, N_hgrid = N_hgrid, N_WSTgrid = N_WSTgrid)

def CALCULUS2(N_hgrid = 256, N_WSTgrid = 256, n_realiz = -1, Ff = 'fiducial'):
    """Evaluates WST coefficients and print them in one/two files (this is an option) for given folders
    using `HaloWST_one_f_MASL`
    """

    # define desired redshift
    # snapnum = 2
    #z_dict = {4:0.0, 3:0.5, 2:1.0, 1:2.0, 0:3.0}
    #redshift = z_dict[snapnum]

    # define root path where to find hale catalogues
    # root = '/media/fuffolo97/HDD1/UNI/Tesi/Halos/FoF/'
    # root = '/media/fuffolo97/HDD1/UNI/Tesi/Halos/'
    root = "/workplace/riccardo/Halos/"

    if n_realiz < 0:
       in_realizations = os.listdir(root+Ff)
       num = len(in_realizations)
    else:
       num = n_realiz
       print(root+Ff)
       in_realizations = os.listdir(root+Ff)[0:num]
       filename = '_coefficients_'+str(N_hgrid)+"_"+str(N_WSTgrid)+"_"+str(num)+'.wst'

       # delete existing file, want a new one (not extending it)
       if os.path.exists('/home/riccardo/WST-files/'+Ff+filename):
           os.remove('/home/riccardo/WST-files/'+Ff+filename)

       for i in in_realizations:
           snapdir = root + Ff + '/' + i
           HaloWST_one_f_MASL(Ff+filename, snapdir, N_hgrid = N_hgrid, N_WSTgrid = N_WSTgrid)



#=== MAIN =======================================================================

# READ list file to use SLURM_ARRAY_TASK_ID
lines = []
with open("file_list_to_create.txt", 'rb') as file:
    lines = file.readlines()

# SAVES parameters, assuming all cosmologies are calculated with same parameters
info = info_name(lines[0].decode("utf-8"))
N_hgrid = info[0]
N_WSTgrid = info[1]

# SAVES cosmology names
name_list = []
for i in range(len(lines)):
    name_list.append(cosmo_parser(lines[i].decode("utf-8")))

if __name__ == "__main__":
    n = sys.argv[1]
    n = int(n)
    if name_list[n] == "fiducial":
        n_realiz = 1000
    elif name_list[n] == "zeldovich":
        n_realiz = 500
    else:
        n_realiz = info[2]
    
    # REMEMBER TO REMOVE!!!
    n_realiz = 1
    
    CALCULUS(N_hgrid=N_hgrid, N_WSTgrid=N_WSTgrid, n_realiz=n_realiz, Ff = name_list[n])